::: список требований/пожеланий :::

алгоритм должен:
... распознавать фон/объект на изображениях с наперёд заданным форматом пикселя (GRAY8, RGB8)
... использовать персональный словарь возможных значений фона для каждого пикселя кадра
... иметь возможность распараллеленной обработки (в идеале - вплоть до попиксельной)
... использовать как можно меньшее количество сравнений в словаре для неизменяющегося фона
... использовать карту маскировки для обозначения обрабатываемой зоны 
... использовать обновляемую карту обратной связи для 
... ... устранения затирания "правильных" объектов и 
... ... принудительного затирания "неправильных" объектов
... ... адаптировать фон на незамаскированных участках кадра


::: описание алгоритма :::
COLOUR_DISTANCE - максимальное цветовое расстояние между цветом и фоном чтобы считаться цветом фона
MRU_SIZE - количество элементов в MRU-списке вариантов фона

PROBABILITY_UPDATE - значение вероятности обновления фонового пикселя
PROBABILITY_MERGE  - значение вероятности встраивания FG-пикселя в фон

FRAME [WxH] -- матрица кадра
MASK [WxH] -- матрица маски обрабатываемой зоны
FEEDBACK [WxH] -- матрица признаков объектов (которые нужно оставить)
RESULT [WxH] -- обновляемая матрица распознанного изображения
MRU_MAP [WxHxDICT_SIZE]

MASK_SKIP -- значение маски для необрабатываемой зоны
MASK_CHECK -- значение маски для зоны обработки

FEEDBACK_KEEP  -- значение признака для правильного объекта (надо оставить как есть)
FEEDBACK_MERGE -- значение признака для неправильного объекта (надо встроить в фон)
FEEDBACK_NONE -- значение признака для самостоятельной обработки

RESULT_BACKGROUND -- значение результата для фонового изображения
RESULT_FOREGROUND -- значение результата для найденных объектов

для каждого X из [1..W], Y из [1..H] цикл
   если MASK [X, Y] = MASK_CHECK то -- производим анализ пикселя кадра
      если FEEDBACK[X, Y] = FEEDBACK_MERGE то -- надо затереть
         RESULT [X, Y] := RESULT_BACKGROUND;
         обновить_фон(X, Y);
      иначе 
         если тут_фон(X, Y) то -- выяснили что тут цвет фона
            RESULT [X, Y] := RESULT_BACKGROUND;
            если FEEDBACK [X, Y] /= FEEDBACK_KEEP то -- можно обновить модель фона
               если хочу_обновить_фон() то
                  обновить_фон(X, Y);
               конец если;
            конец если; -- для обновления фона
         иначе -- выяснили что тут не фоновый цвет
            если FEEDBACK [X, Y] /= FEEDBACK_KEEP и хочу_встроить_в_фон() то
               -- попробуем перекрасить в фон
               NEIGHBOUR := некий_сосед(X, Y);
               если RESULT [NEIGHBOUR.X, NEIGHBOUR.Y] = RESULT_BACKGROUND то 
                  -- на предыдущем (FIXME!) цикле имели фон в качестве соседа 
                  -- можно обновить модель фона в текущей точке
                  обновить_фон(X, Y);
                  RESULT [X, Y] := RESULT_BACKGROUND;
               конец если;
            иначе -- оставляем объект
               RESULT [X, Y] := RESULT_FOREGROUND;
            конец если; -- возможная перекраска в фон
         конец если; -- работа с результатами детектора фона в точке
      конец если; -- затирать или обрабатывать
   иначе -- неанализированный пиксель - в нём может быть только фон
      RESULT [X, Y] := RESULT_BACKGROUND;
   конец если; -- работа с маской
конец цикла; -- пробег по всем пикселям кадра


логическая функция тут_фон(X, Y) 
    COLOUR := FRAME [X, Y];
    для Ix из [1..MRU_SIZE] цикл
        если цветовая_разница(MRU_MAP [X, Y, Ix], COLOUR) < COLOUR_DISTANCE то
            -- это фоновый цвет
            если Ix > 1 то -- можно поднять цвет по MRU-списку
                обменять (MRU_MAP [X, Y, Ix], MRU_MAP [X, Y, Ix - 1]);
            конец если;
            вернуть TRUE;
        конец если;
    конец цикла;
    вернуть FALSE;
конец тут_фон;


процедура обновить_фон(X, Y) 
    MRU_MAP [X, Y, случайное_из (1, DICT_SIZE)] := FRAME [X, Y];
конец обновить_фон;

логическая функция хочу_обновить_фон()
    вернуть случайное_из (1, 100) < PROBABILITY_UPDATE;
конец хочу_обновить_фон;


логическая функция хочу_встроить_в_фон()
    вернуть случайное_из (1, 100) < PROBABILITY_MERGE;
конец хочу_обновить_фон;


функция некий_сосед (X, Y)
    NEIGHBOURS [8] = ((X = -1, Y = -1), (X = 0, Y = -1), (X = 1, Y = -1),
                      (X = -1, Y =  0),                  (X = 1, Y =  0),
                      (X = -1, Y =  1), (X = 0, Y =  1), (X = 1, Y =  1));
    NEIGHBOUR = NEIGHBOURS [случайное_из (1, 8)];
    если (X = 1 и NEIGHBOUR.X < 0) или (X = W и NEIGHBOUR.X > 0) то
        NEIGHBOUR.X := X;
    иначе
        NEIGHBOUR.X := NEIGHBOUR.X + X;
    конец если;

    если (Y = 1 и NEIGHBOUR.Y < 0) или (Y = H и NEIGHBOUR.Y > 0) то
        NEIGHBOUR.Y := Y;
    иначе
        NEIGHBOUR.Y := NEIGHBOUR.Y + Y;
    конец если;

    вернуть NEIGHBOUR;
конец некий_сосед;

целая функция случайное_из (MIN, MAX)
    вернуть MIN + ( RANDOM() MODULO (MAX - MIN + 1) )
конец случайное_из;

процедура обменять (ссылка на A, ссылка на B)
    C := A;
    A := B;
    B := C;
конец обменять;
