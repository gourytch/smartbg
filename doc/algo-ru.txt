::: список требований/пожеланий :::

алгоритм должен:
... распознавать фон/объект на изображениях с наперёд заданным форматом пикселя (GRAY8, RGB8)
... использовать персональный словарь возможных значений фона для каждого пикселя кадра
... иметь возможность распараллеленной обработки (в идеале - вплоть до попиксельной)
... использовать как можно меньшее количество сравнений в словаре для неизменяющегося фона
... использовать карту маскировки для обозначения обрабатываемой зоны 
... использовать обновляемую карту обратной связи для 
... ... устранения затирания "правильных" объектов и 
... ... принудительного затирания "неправильных" объектов
... ... адаптировать фон на незамаскированных участках кадра


::: описание алгоритма :::

FRAME [WxH] -- матрица кадра
MASK [WxH] -- матрица маски обрабатываемой зоны
FEEDBACK [WxH] -- матрица признаков объектов (которые нужно оставить)
RESULT [WxH] -- обновляемая матрица распознанного изображения

MASK_SKIP -- значение маски для необрабатываемой зоны
MASK_CHECK -- значение маски для зоны обработки

FEEDBACK_KEEP  -- значение признака для правильного объекта (надо оставить как есть)
FEEDBACK_MERGE -- значение признака для неправильного объекта (надо встроить в фон)
FEEDBACK_NONE -- значение признака для самостоятельной обработки

RESULT_BACKGROUND -- значение результата для фонового изображения
RESULT_FOREGROUND -- значение результата для найденных объектов

для каждого X из [1..W], Y из [1..H] цикл
   если MASK [X, Y] = MASK_CHECK то -- производим анализ пикселя кадра
      если FEEDBACK[X, Y] = FEEDBACK_MERGE то -- надо затереть
         RESULT [X, Y] := RESULT_BACKGROUND;
         обновить_фон(X, Y);
      иначе 
         если тут_фон(X, Y) то -- выяснили что тут цвет фона
            RESULT [X, Y] := RESULT_BACKGROUND;
            если FEEDBACK [X, Y] /= FEEDBACK_KEEP то -- можно обновить модель фона
               если хочу_обновить_фон() то
                  обновить_фон(X, Y);
               конец если;
            конец если; -- для обновления фона
         иначе -- выяснили что тут не фоновый цвет
            если FEEDBACK [X, Y] /= FEEDBACK_KEEP и хочу_встроить_в_фон() то
               -- попробуем перекрасить в фон
               NEIGHBOUR_X, NEIGHBOUR_Y := некий_сосед(X, Y);
               если RESULT [NEIGHBOUR_X, NEIGHBOUR_Y] = RESULT_BACKGROUND то 
                  -- на предыдущем (FIXME!) цикле имели фон в качестве соседа 
                  -- можно обновить модель фона в текущей точке
                  обновить_фон(X, Y);
                  RESULT [X, Y] := RESULT_BACKGROUND;
               конец если;
            иначе -- оставляем объект
               RESULT [X, Y] := RESULT_FOREGROUND;
            конец если; -- возможная перекраска в фон
         конец если; -- работа с результатами детектора фона в точке
      конец если; -- затирать или обрабатывать
   иначе -- неанализированный пиксель - в нём может быть только фон
      RESULT [X, Y] := RESULT_BACKGROUND;
   конец если; -- работа с маской
конец цикла; -- пробег по всем пикселям кадра

::: TODO :::
раскрыть следующие элементы алгоритма:
  индекс_фона(X, Y) -- найти индекс первого значения фона, для которого цвет пиксела подходит
  обновить_фон(X, Y) -- вставить значение цвета пиксела в MRU-словарь
  хочу_обновить_фон() -- выдаёт TRUE с некоторой наперед заданной вероятностью PROBABILITY_UPDATE
  хочу_встроить_в_фон() -- выдаёт TRUE с некоторой наперед заданной вероятностью PROBABILITY_MERGE
  некий_сосед(X,Y) -- выдаёт пару X', Y' с валидными координатами соседнего пиксела
                      (X' в [1..W])
                      (Y' в [1..H])
                      (X' - X в [-1..+1])
                      (Y' - Y в [-1..+1])
                      (((X' = X) и (Y' = Y)) = FALSE)
